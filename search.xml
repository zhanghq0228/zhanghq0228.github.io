<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>复习笔记整理--vue.js</title>
      <link href="/2019/07/03/vue/"/>
      <url>/2019/07/03/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-js"><a href="#vue-js" class="headerlink" title="vue.js"></a>vue.js</h1><hr><h2 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1 生命周期:"></a>1 生命周期:</h2><p>beforeCreate / create (创建前/创建后)<br>beforeMount / mount (挂载前 / 挂载)<br>beforeUpdate / update (更新前 / 更新)<br>beforeDestroy / destroy (销毁前 / 销毁)<br>第一次加载触发 beforeCreat、create、beforeMount、mount</p><h2 id="2-vue-路由："><a href="#2-vue-路由：" class="headerlink" title="2 vue 路由："></a>2 vue 路由：</h2><ul><li>1.hash 模式：window.localtion.hash 来获取,<br>特点:hash 虽然在 url 中,但不被包括在 HTTP 请求中,用来指导浏览器动作对服务器安全无用,hash 不会重载页面</li><li>2.history:采用 HTML5 新特性,提供两个新方法 pushState(), replaceState()两个方法对浏览器历史记录进行修改,以及 popState 事件监听状态变更</li></ul><h2 id="3-路由钩子函数"><a href="#3-路由钩子函数" class="headerlink" title="3 路由钩子函数:"></a>3 路由钩子函数:</h2><p>在某些情况下，当路由跳转前或跳转后、进入、离开某一个路由前、后，需要做某些操作，就可以使用路由钩子来监听路由的变化</p><h4 id="全局路由钩子："><a href="#全局路由钩子：" class="headerlink" title="全局路由钩子："></a>全局路由钩子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    //会在任意路由跳转前执行，next一定要记着执行，不然路由不能跳转了</span><br><span class="line">  console.log(&apos;beforeEach&apos;)</span><br><span class="line">  console.log(to,from)</span><br><span class="line">  //</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line">//</span><br><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">    //会在任意路由跳转后执行</span><br><span class="line">  console.log(&apos;afterEach&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="单个路由钩子："><a href="#单个路由钩子：" class="headerlink" title="单个路由钩子："></a>单个路由钩子：</h4><p>只有 beforeEnter，在进入前执行，to 参数就是当前路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/foo&apos;,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="路由组件钩子："><a href="#路由组件钩子：" class="headerlink" title="路由组件钩子："></a>路由组件钩子：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, from, next) &#123;</span><br><span class="line">  // 在渲染该组件的对应路由被 confirm 前调用</span><br><span class="line">  // 不！能！获取组件实例 `this`</span><br><span class="line">  // 因为当守卫执行前，组件实例还没被创建</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, from, next) &#123;</span><br><span class="line">  // 在当前路由改变，但是该组件被复用时调用</span><br><span class="line">  // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br><span class="line">  // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">  // 导航离开该组件的对应路由时调用</span><br><span class="line">  // 可以访问组件实例 `this`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父子组件传值："><a href="#父子组件传值：" class="headerlink" title="父子组件传值："></a>父子组件传值：</h2><ul><li>1.子组件在 props 中创建一个属性，用来接收父组件传递的值</li><li>2.父组件中注册子组件</li><li>3.在子组件标签中绑定子组件 props 中创建的属性</li><li>4.把需要传递的子组件值赋给该属性<br><img src="../images/vue1.png" alt="原型"><br><img src="../images/vue2.png" alt="原型"></li></ul><h2 id="子向父组件传值"><a href="#子向父组件传值" class="headerlink" title="子向父组件传值"></a>子向父组件传值</h2><ul><li>1.子组件中需要以某种方式触发一个自定义组件</li><li>2.将需要传的值作为$emit 的第二个参数，该值作为实参传给响应自定义事件的方法</li><li>3.在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听</li></ul><p><strong>子组件创建按钮绑定事件，事件函数中$emit 中触发自定义事件传递参数</strong><br><img src="../images/vue3.png" alt="原型"><br><img src="../images/vue4.png" alt="原型"></p><p><strong>父组件中子标签监听该自定义</strong></p><p><img src="../images/vue5.png" alt="原型"><br><img src="../images/vue6.png" alt="原型"></p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>状态管理,在 main 中引入 store,</p><ul><li>1.state : 存放数据状态, 不可以直接修改里面的数据</li><li>2.mutations : 动态修改 vuex 中的数据状态</li><li>3.getters : 类似 vue 的计算属性,用来过滤一些数据</li><li>4.actions : 异步处理 mutation 中数据或者处理数据的方法,</li><li>5.store.dispatch 分发 action</li></ul><p>vuex 提供四个辅助函数 <strong>mapState mapGetter mapAction mapMutation</strong></p><ul><li>mapAction ==&gt; this.$store.dispatch( ) 分发 action</li><li>mapMutation ==&gt; this.$store.commit( )</li></ul><h2 id="浅谈-vue-双向绑定原理"><a href="#浅谈-vue-双向绑定原理" class="headerlink" title="浅谈 vue 双向绑定原理"></a>浅谈 vue 双向绑定原理</h2><p><img src="../images/vue7.png" alt="原型"><br>vm 的核心是 view 和 data</p><ul><li>当 data 有变化的时候它通过 Object.defineProperty(）方法中的 set 方法进行监控，并调用在此之前已经定义好 data 和 view 的关系了的回调函数，来通知 view 进行数据的改变</li><li>而 view 发生改变则是通过底层的 input 事件来进行 data 的响应更改<br>vue 是通过 Object.defineProperty()来实现数据劫持的。</li></ul><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            console.log(&apos;我被获取了&apos;)</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newVal) &#123;</span><br><span class="line">            console.log(&apos;我被设置了&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.name = &apos;fei&apos;;//在给obj设置name属性的时候，触发了set这个方法</span><br><span class="line">var val = obj.name;//在得到obj的name属性，会触发get方法</span><br></pre></td></tr></table></figure><p>已经了解到 vue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。</p><h4 id="实现最简单的双向绑定"><a href="#实现最简单的双向绑定" class="headerlink" title="实现最简单的双向绑定"></a>实现最简单的双向绑定</h4><p>我们知道通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;inp&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var obj  = &#123;&#125;;</span><br><span class="line">        var demo = document.querySelector(&apos;#demo&apos;)</span><br><span class="line">        var inp = document.querySelector(&apos;#inp&apos;)</span><br><span class="line">        Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class="line">            get: function() &#123;</span><br><span class="line">                return val;</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function (newVal) &#123;//当该属性被赋值的时候触发</span><br><span class="line">                inp.value = newVal;</span><br><span class="line">                demo.innerHTML = newVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        inp.addEventListener(&apos;input&apos;, function(e) &#123;</span><br><span class="line">            // 给obj的name属性赋值，进而触发该属性的set方法</span><br><span class="line">            obj.name = e.target.value;</span><br><span class="line">        &#125;);</span><br><span class="line">        obj.name = &apos;fei&apos;;//在给obj设置name属性的时候，触发了set这个方法</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="vue-如何实现"><a href="#vue-如何实现" class="headerlink" title="vue 如何实现"></a>vue 如何实现</h4><p><img src="../images/vue8.png" alt="原型"></p><h2 id="vue-页面缓存"><a href="#vue-页面缓存" class="headerlink" title="vue 页面缓存"></a>vue 页面缓存</h2><p>vue2.0 提供了一个 keep-alive 组件<br>用来缓存组件,避免多次加载相应的组件,减少性能消耗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;component&gt;</span><br><span class="line">  &lt;!-- 组件将被缓存 --&gt;</span><br><span class="line">&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &apos;/&apos;, redirect: &apos;/index&apos;,  component: Index, meta: &#123; keepAlive: true &#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/common&apos;,</span><br><span class="line">      component: TestParent,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; path: &apos;/test2&apos;, component: Test2, meta: &#123; keepAlive: true &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    // 表示index和test2都使用keep-alive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>复习笔记整理--JS篇</title>
      <link href="/2019/07/02/JS/"/>
      <url>/2019/07/02/JS/</url>
      
        <content type="html"><![CDATA[<h1 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><ul><li><ol><li>基本数据类型 : string / number / boolean / underfined /null</li></ol></li><li><ol start="2"><li>复杂数据类型 : Object / Array / Date / Function / String / Number / Math / Null</li></ol></li><li><ol start="3"><li>引用类型 : 对象(Object) 数组(Array) 函数(Function)</li></ol></li></ul><p>面向对象的三大特性：封装（复用信息隐蔽），继承（获取已存在对象的已知属性和方法），多态（同一操作会产生不同的解析和行为）</p><h2 id="2-原型-构造函数-实例"><a href="#2-原型-构造函数-实例" class="headerlink" title="2.原型 / 构造函数 / 实例"></a>2.原型 / 构造函数 / 实例</h2><ul><li>1.<strong>原型(protoType)</strong> : 在构造函数创建出来的时候,系统会默认帮构造函数创建一个与之关联的自定义构造函数,构造函数的原型对象默认是一个空对象,自定义构造函数创建出来的对象自动拥有和共享该构造函数的原型对象中的所有属性和方法,构造函数 <strong>.prototype</strong> 指向他的原型对象,或者实例 <strong>.__proto__</strong> 指向创建实例对象的构造函数原型对象,原型对象的 constructor 属性指向对应的构造函数</li><li><ol start="2"><li><strong>构造函数:</strong> 可以通过 new 来创建一个对象的函数</li></ol></li><li><ol start="3"><li><strong>实例:</strong> 通过构造函数和 new 创建出来的对象,实例可以通过 <strong>.__proto__</strong> 指向原型,通过 constructor 指向构造函数<br><img src="../images/yuanxing.png" alt="原型"></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//instance 为实例,构造 x 函数 Object,构造函数有一个 prototype 属性指向原型对象</span><br><span class="line">const instance = new Object()</span><br><span class="line">// 原型对象 prototype</span><br><span class="line">const prototype = Object.prototype</span><br><span class="line">实例.\_ _proto _ \_== 原型</span><br><span class="line">原型.constructor == 构造函数</span><br><span class="line">构造函数.prototype == 原型</span><br><span class="line">实例.construtor == 构造函数</span><br></pre></td></tr></table></figure><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h2><p>原型链是有原型对象组成,每个对象都有 <strong>.__proto__</strong> 属性,指向创建该对象的构造函数的原型,<strong>.__proto__</strong> 见对象连接起来组成原型链。是一个用来 <strong>实现继承和共享属性</strong>的有限对象链。</p><ul><li><ol><li>属性查找机制: 当查找对象的属性时,如果实例对象自身不存在该属性,则沿着原型链往上一级查找,找到则输出,找不到继续往上查找,直到找到顶层 Object.protoType,如果还没有就输出 underfined</li></ol></li><li><ol start="2"><li>属性修改机制: 只会修改实例对象本身属性,如果不存在,则添加该属性,如果需要修改原型属性时,则可以用 b.prototype.x = 2 ;但是这样会造成所有继承该对象的实例的属性发生改变。</li></ol></li></ul><p><img src="../images/yuanxinlian.png" alt="原型"></p><h2 id="4-执行上下文（EC）"><a href="#4-执行上下文（EC）" class="headerlink" title="4.执行上下文（EC）"></a>4.执行上下文（EC）</h2><p>执行上下文可以简单理解为一个对象：</p><ul><li><ol><li>它包含了三个部分：<ol><li>变量对象（VO）</li><li>作用域链（词法作用域）</li><li>this 指向</li></ol></li></ol></li><li><ol start="2"><li>他的类型：<ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol></li></ol></li><li><ol start="3"><li><p>代码执行过程：</p><ol><li>创建全局上下文（global EC）</li><li>全局执行上下文(caller)逐行自上而下执行。遇到函数时，函数执行上下文（callee）被 push 到执行栈顶层</li><li>函数执行上下文被激活，成为 active EC,开始执行函数中的代码，cakker 被挂起</li><li>函数执行后，callee 被 pop 移出出执行栈，控制权交还全局上下文，继<br>续执行</li></ol></li></ol></li></ul><p>##5.变量对象<br>变量对象，是执行上下文中的一部分，可以抽象为一种<strong>数据作用域</strong>，其实也可以理解为就是一个简单的对象，他储存着该执行上下文中的所有<strong>变量和函数声明（不包含函数表达式）</strong></p><p>##6.作用域<br><strong>变量作用域:</strong> 变量作用域分为两种:全局变量和局部变量<br>执行上下文中还包含了作用域链。作用域其实可以理解为该上下文中声明的变量和声明的作用范围。可分为<strong>块级作用域</strong>和<strong>函数作用域</strong><br>特性：</p><ul><li>1.<strong>声明提前：</strong> 一个声明在函数体内都是可见的，函数优先于变量。</li><li>2.非匿名自执行函数，函数变量为只读状态，无法被修改</li></ul><p>##7.作用域链<br>我们可以在执行上下文是访问到父级甚至全局变量，这便是作用域链，作用域链可以理解为一组对象列表，包含<strong>父级和自身的变量对象</strong>，因此我们便能通过作用域链访问到父级里的声明或者函数</p><p>##8.闭包<br>闭包：闭包就是能够获取其他函数内部的变量的函数，由于 js 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为<strong>定义在一个函数内部的函数</strong>，所以本质上闭包就是将函数内部和函数外部连接起来的一座桥梁，<br><strong>闭包的用途：</strong> 第一个就是读取函数内部的变量，第二个就是让这些变量的值始终保存在内存中<br>使用闭包会使得函数中的变量一直保存在内存中，内存消耗大会造成性能问题，在 ie 中会造成内存泄漏。<br>在闭包中，多个子函数会同时指向父级，是完全共享，因此当父级变量被修改时，所有的子函数都会受到影响。<br>解决办法：</p><ul><li>1.变量以函数参数的形式传入；</li><li>2.使用块级作用域，避免共享</li></ul><p>##9.对象拷贝</p><ul><li>1.浅拷贝:以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响<br>①Object.assign<br>② 展开运算符(…)</li><li>2.深拷贝：完全拷贝一个新对象，修改时元对象不再受到任何影响<br>①JSON.parse（JSON.stringify（obj））：性能最快 1)具有循环引用的对象时，报错 2)当值为 underfined 或者 symbol 时，无法拷贝<br>② 递归进行逐一赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">    if (typeof obj == &apos;object&apos;) &#123;</span><br><span class="line">      // 复杂数据类型</span><br><span class="line">      var result = obj.construction == Array ? [] : &#123;&#125;</span><br><span class="line">      for (const key in obj) &#123;</span><br><span class="line">        result[key] == typeof obj[key] == &apos;object&apos; ? deepCopy(obj[key]) : obj[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var result = obj</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##11.instanceof</p><ul><li>1.能在实例的原型对象链中找到该构造函数的 prototype 属性所指向的原型对象，返回 true</li><li>2.获取对象的真是属性 object.prototype.toString.call(具体对象)</li></ul><p>##12.继承<br>在 js 中，继承通常指原型链继承，指定原型，通过原型链继承原型上的属性或者方法。<br>继承：通过一定的方式实现让某一个类型 a 获取另外一个类型 b 的属性和方法，其中 a 称为子类型，b 称为父类型或者超类型<br><strong>原型式继承：</strong> 设置原型对的属性和方法，让所有的实例化对象都拥有属性和方法<br><strong>原型链继承：</strong> 实质就是重写原型对象，重写原型对象的位置，必须是先实现原型继承，然后在设置子对象的原型属性和方法，完成继承后不能使用字面量方式创建原型<br><strong>经典继承：</strong> 要用到 call 和 apply 方法，解决了实例对象的共享问题<br><strong>组合继承：</strong> 使用原型链实现对原型属性和方法的继承，用伪造构造函数实现属性的继承<br>使用 es6 的语法糖 class / extends</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//原型式继承</span><br><span class="line"> //1.设置父对象的构造函数</span><br><span class="line"> function Father() &#123;</span><br><span class="line">   this.name = &apos;father&apos;</span><br><span class="line">   this.showName = function () &#123;</span><br><span class="line">     console.log(this.name)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //3.提供子对象的构造函数</span><br><span class="line"> function Son() &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> //4.设置原型继承</span><br><span class="line"> Son.prototype = new Father()</span><br><span class="line"> //5.实例化对象,实现继承</span><br><span class="line"> var son1 = new Son()</span><br><span class="line"> console.log(son1.name)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//原型链继承</span><br><span class="line">//设置父类型</span><br><span class="line">function Father() &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.showName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.设置父类型原型对象上的属性和方法</span><br><span class="line">Father.prototype.info = &apos;father info&apos;</span><br><span class="line">Father.prototype.showInfo = function () &#123;</span><br><span class="line">  console.log(this.info)</span><br><span class="line">&#125;</span><br><span class="line">//3,提供子类型</span><br><span class="line">function Son() &#123;&#125;</span><br><span class="line">//4.设置继承,继承父类型上的所有属性和方法</span><br><span class="line">Son.prototype = new Father()</span><br><span class="line">//5.将子类的构造函数 重新指向会子类型</span><br><span class="line">Son.prototype.construction = Son</span><br><span class="line">var son2 = new Son()</span><br><span class="line">console.log(son2.info) //father info</span><br><span class="line">console.log(son2.showInfo()) //father info</span><br><span class="line">son2.info = &apos;123&apos;</span><br><span class="line">var father = new Father()</span><br><span class="line">console.log(father.info) //father info</span><br><span class="line">console.log(son2.info) //123</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;dog&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  showName(say) &#123;</span><br><span class="line">    console.log(this.name + &apos;name&apos; + say)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.showName(&apos;阿黄&apos;) //dogname阿黄</span><br><span class="line"></span><br><span class="line">class Cat extends Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.name = &apos;猫&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat1 = new Cat()</span><br><span class="line">cat1.showName(&apos;橘猫&apos;) //猫name橘猫</span><br></pre></td></tr></table></figure><p>##13.类型转换<br>类型转换分为强类型转换和隐式类型转换<br>强制：（parseInt,parseFloat,Number()）<br>隐式：（==) 1 == ”1” //true<br>null == undefined //true</p><p>##14.模块化<br>模块化开发可以大大提高项目的可维护性，可拓展性和可协作性，通常，我们在浏览器中使用 es6 的模块化支持，在 node 中使用 common.js 的模块化支持<br>分类：</p><ul><li>1.es6：import / exports</li><li>2.commonjs : require / module.export / export</li><li>3.amd : require / defined</li></ul><p>require 和 import 区别：</p><ul><li>1.require 支持动态导入，import 不支持</li><li>2.require 是同步导入，import 属于异步导入</li><li>3.require 是值拷贝，导出值变化不会影响导入值，import 指向内存地址，导入值会随导出值而变化</li></ul><p>##15.防抖与节流<br>防抖与节流函数是一种最常用的高频触发优化方式，能对性能有较大的帮助。</p><ul><li>1.防抖：将多次高频操作优化为只在最后一次执行，通常使用场景为：用户输入，只需要再输入完成后做一次验证即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function dedule(fn, wait = 50, immdital) &#123;</span><br><span class="line">    var timer</span><br><span class="line">    return function () &#123;</span><br><span class="line">      if (immdital) &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">      if (timer) clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>2.节流：每隔一段时间后执行一次，也就是降低频率，将最高频操作优化成低频操作，通常使用场景：滚动条事件或者 resize 事件，通常每隔 100~500ms 执行一次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function rhtottle(fn, wait = 50, immediately) &#123;</span><br><span class="line">    var timer</span><br><span class="line">    return function () &#123;</span><br><span class="line">      if (immediately) &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">        immediately = false</span><br><span class="line">      &#125;</span><br><span class="line">      if (!timer) &#123;</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          fn.call(this, arguments)</span><br><span class="line">          timer = null</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##16.函数执行改变 this<br>由于 JS 的设计原理：在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数内部获取当前运行环境，this<br>函数运行环境，谁调用了函数就指向谁</p><ul><li>1.obj.fn()，obj 调用函数，即函数中的 this == obj</li><li>2.fn（），这里就是 window.fn（），this == window</li></ul><p>手动改变 this 指向</p><ul><li>1.call：fn.call（target，1,2）</li><li>2.apply：fn.apply(terger, [1 , 2] )</li><li>3.bind：fn.bind(target)(1,2)</li></ul><p><strong>call 和 apply 和 bind 都是 Function 对象自带三个方法，都是为了改变函数内部 this 指向</strong></p><ul><li>1.三者的第一个参数都是 this 指向的对象</li><li>2.都可以利用后- 续参数传值</li><li>3.bind 返回对应<strong>函数</strong>，便于稍后调用，apply 和 call 则是立即调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function fruits() &#123;&#125;</span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">  color: &apos;red&apos;,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    console.log(&apos;My color is&apos; + this.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var apple = new fruits;</span><br><span class="line">apple.say();</span><br><span class="line">// 此时方法里面的this 指的是fruits</span><br><span class="line">// 结果： My color is red</span><br><span class="line">var banana = &#123;</span><br><span class="line">  color: &apos;yellow&apos;</span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana);</span><br><span class="line">//此时的this的指向已经同过call（）方法改变了，指向的是banana，this.color就是banana.color=&apos;yellow&apos;;</span><br><span class="line">//结果是My color is yellow</span><br><span class="line">apple.say.apply(banana);</span><br><span class="line">//同理，此时的this的指向已经同过apply（）方法改变了，指向的是banana，this.color就是banana.color =&apos;yellow&apos;;</span><br><span class="line">//My color is yellow</span><br><span class="line">// 如果传入的是 null：</span><br><span class="line">apple.say.apply(</span><br><span class="line">  null</span><br><span class="line">);</span><br><span class="line">// null是window下的，此时，this 就指向了window ，但是window下并没有clolr这个属性，</span><br><span class="line">//因此this.clolr就是window.color=undefined;//My color is undefined</span><br><span class="line">var bar = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo = &#123;</span><br><span class="line">  x: 3</span><br><span class="line">&#125;</span><br><span class="line">bar(); // undefinedvar</span><br><span class="line">func = bar.bind(foo);</span><br><span class="line">//此时this已经指向了foo，但是用bind（）方法并不会立即执行，</span><br><span class="line">//而是创建一个新函数，如果要直接调用的话 可以 bar.bind(foo)（）</span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure><p>##17.ES6 / ES7</p><ul><li>1.声明<br>①let / const：块级作用域、不存在变量提升、暂时性死区、不允许重复声明<br>②const：声明常量、常量的值不可被修改，但是 const 指向一个地址时候，是可以被修改的彻底将对象冻结可以使用 Obj.freeze()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">arr.fn = &apos;被改变了&apos;</span><br><span class="line">console.log(arr) //&#123; fn: &apos;被改变了&apos;&#125;</span><br></pre></td></tr></table></figure><ul><li>2.解构赋值<br>es6 允许按照一定的模式，从数组和对象中提取值，对对象进行赋值，称为解构<br>本质上,这种写法属于”模式匹配”,只要等号两边模式相同,左边的变量就会被赋予对应值,</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [12,13]</span><br><span class="line">console.log(a) //12</span><br><span class="line">console.log(b) //13</span><br><span class="line">console.log(c) //undefined</span><br><span class="line"></span><br><span class="line">let [a,...b] = [12,13,14,15]</span><br><span class="line">console.log(a) //12</span><br><span class="line">console.log(b) //[13,14,15]</span><br></pre></td></tr></table></figure><ul><li>3.class / extend ：类声明和继承<br>class 语法相对原型、构造函数、继承更接近传统语法，可以让对象原型写法更加清晰</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;dog&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  showName(say) &#123;</span><br><span class="line">    console.log(this.name + &apos;name&apos; + say)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.showName(&apos;阿黄&apos;) //dogname阿黄</span><br><span class="line"></span><br><span class="line">class Cat extends Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.name = &apos;猫&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat1 = new Cat()</span><br><span class="line">cat1.showName(&apos;橘猫&apos;) //猫name橘猫</span><br></pre></td></tr></table></figure><ul><li><p>4.Set / Map : 新的数据结构 set 中值是唯一的，可以用来进行数组去重<br>Map:一种新的数据结构,键的范围不限于字符串,各种类型的值都可以当做键</p></li><li><p>5.异步解决方案：</p><ul><li><p>①promise：使用同步的方法解决异步操作，解决 ajax 的回调地狱</p><pre><code>1).then()返回一个 promise 对象，可以连续调用.then()完成回调2)all 方法 then 方法 catch 方法3)promise 是一个对象可以通过 new 调用，有两个参数 resolve（决定）和 reject（拒绝）这两个参数页数函数，接着可以使用。then 调用 promise。</code></pre></li><li><p>②generator（生产者）：<br>但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态（yield 语句在英语里的意思就是“产出”）。<br>1)yield：暂停代码<br>2)next（）：继续执行代码</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function\* helloWorld() &#123;</span><br><span class="line">   yield &apos;hello&apos;;</span><br><span class="line">   yield &apos;world&apos;;</span><br><span class="line">   return &apos;ending&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const generator = helloWorld();</span><br><span class="line">generator.next() // &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class="line">generator.next() // &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class="line">generator.next() // &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class="line">generator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>③await / async：是 generator 的语法糖，babel 中是基于 promise 实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function getUserByAsync()&#123;</span><br><span class="line"> let user = await fetchUser();</span><br><span class="line"> return user;</span><br><span class="line"> &#125;</span><br><span class="line"> const user = await getUserByAsync()</span><br><span class="line"> console.log(user)</span><br></pre></td></tr></table></figure><p>async(异步操作)/await(等待操作) 简单讲就是 async 函数会返回一个 promises 对象,await 就是等待,等待所有的异步操作完成后再调用,完成将异步变成同步操作,终结回调,当然 async 内部发生错误会被 promise 对象变成 reject 对象被 catch 捕捉,一旦 await 抛出错误后续就不再执行了</p><ul><li>6.模板语法 ：<br><code>${varible}</code> 字符串添加遍历接口,可以被 for…of 遍历循环</li><li>7.模块（module）体系<br>impotent / export default</li><li>8.箭头函数:<br>没有 arguments,没有 prototype 属性,不可以作为构造函数,改变 this 指向,指向上下文</li><li>9.扩展运算符(…)<br>Object.assign()对象合并</li><li>10.es6 数组<br>Array.of(1,2,3,4) //[1,2,3,4] 将数组中的所有值作为元素形成一个新数组<br>Array.from([1, ,2]) //[1,undefined,2] 将数组对象或者可迭代对象转化为数组<br>Array(3).fill({}) //[{},{},{}] 填充</li></ul><h2 id="18-函数柯里化"><a href="#18-函数柯里化" class="headerlink" title="18.函数柯里化"></a>18.函数柯里化</h2><p>在函数中先填充几个函数 然后返回一个新函数 再不入侵函数的前提下 为函数 <strong>预置通用参数</strong> 供多次重复使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const add = function add(x)&#123;</span><br><span class="line">  return function (y)&#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const add1 = add(1)</span><br><span class="line">add1(2) === 3</span><br><span class="line">add1(20) === 21</span><br></pre></td></tr></table></figure><h2 id="19-数组"><a href="#19-数组" class="headerlink" title="19.数组"></a>19.数组</h2><p>数组去重:</p><ul><li><ol><li>双层循环 外层循环元素 内层循环值进行对比 有值就忽略 不同值就 push 进新数组</li></ol></li><li><ol start="2"><li>双层循环 外层循环元素 内层循环值进行对比 splice 进行删除 并删除 length</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6,7,5,4,3,1,4,5,2]</span><br><span class="line">function uniqe(arr)&#123;</span><br><span class="line">  for (let i = 0; i&lt; arr.length; i++)&#123;</span><br><span class="line">    for( let j = i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">      if( arr[i] == arr[j])&#123;</span><br><span class="line">        arr.splice(j,1)</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqe(arr)) //[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>使用 es6 的 set 方法</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function uniqe1(arr)&#123;</span><br><span class="line">  return [...new Set(arr)]</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqe1(arr)</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>利用对象属性去重 每次取出原数组元素 然后在对象中访问这个对象 存在就重复</li></ol></li><li><ol start="5"><li>利用下标 indexOf</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [1, 2, 3, 4, 5, 67, 5, 23, 4, 2, 1, 54, 3]</span><br><span class="line"></span><br><span class="line">function unqie2(arr) &#123;</span><br><span class="line">  var res = []</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (res.indexOf(arr[i]) === -1) &#123;</span><br><span class="line">      res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br><span class="line">console.log(unqie2(arr1)) //[1, 2, 3, 4, 5, 67, 23, 54]</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>数组的一些常用方法<br>map: 遍历数组 返回新数组<br>forEach: 无法 break 可以在 try / catch 中使用 throw new error 来停止<br>filter: 过滤<br>join: 通过制定连接符生成字符串<br>push / pop : 头尾插入<br>unshift / shift 头尾删除<br>concat 连接数组<br>slice(start,end) 截取后返回新数组<br>splice(start, unmber) 返回删除生成的数组<br>indexOf: 查找数组</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set();</span><br><span class="line">[2,3,4,5,2,2] .map( x=&gt;s.add(x) )</span><br><span class="line">for( let i of s )&#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;//2,3,4,5</span><br></pre></td></tr></table></figure><p><strong>数组去重 关于一些长数组 或者针对数组去重进行优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**数组去重</span><br><span class="line"> * 对于多大数组 进行先排序 arr.sort 在过滤去重</span><br><span class="line"> * 1.使用递归去重</span><br><span class="line"> * 2.使用 filter()过滤重复元素</span><br><span class="line"> */</span><br><span class="line">Array.prototype.distinct = function () &#123;</span><br><span class="line">  var arr = this,</span><br><span class="line">    len = arr.length</span><br><span class="line">  //arr.sort() 对数组进行排序 只能传一个参数</span><br><span class="line">  arr.sort(function (a, b) &#123;</span><br><span class="line">    //对数组进行排序才能方便比较</span><br><span class="line">    return a - b</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function loop(index) &#123;</span><br><span class="line">    //递归判断前一个元素是否等于当前元素(从后往前排序)</span><br><span class="line">    if (index &gt;= 1) &#123;</span><br><span class="line">      if (arr[index] === arr[index - 1]) &#123;</span><br><span class="line">        arr.splice(index, 1)</span><br><span class="line">      &#125;</span><br><span class="line">      loop(index - 1) //递归loop函数进行去重</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop(len)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56</span><br><span class="line">]</span><br><span class="line">var b = a.distinct()</span><br><span class="line">console.log(b.toString()) //1,2,3,4,5,6,45,56</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function unique(a) &#123;</span><br><span class="line">return a.concat().sort().filter(function (item, pos, ary) &#123;</span><br><span class="line">  return !pos || item != ary[pos - 1]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var d = [1, 1, 3, 2, 1, 2, 4]</span><br><span class="line">var ans = unique(d)</span><br><span class="line">console.log(ans) // =&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><h2 id="20-定义函数方式"><a href="#20-定义函数方式" class="headerlink" title="20.定义函数方式"></a>20.定义函数方式</h2><ul><li><ol><li>函数声明（function name（）{}）</li></ol></li><li><ol start="2"><li>函数表达式 var name = function（）{}</li></ol></li><li><ol start="3"><li>使用 Function 类型的构造器创建 var name = new Function（）{}</li></ol></li></ul><h2 id="21-import-和-require-区别："><a href="#21-import-和-require-区别：" class="headerlink" title="21.import 和 require 区别："></a>21.import 和 require 区别：</h2><p>Require:遵循 AMD 规范引入<br>import 是 es6 的一个语法标准，如果想要兼容浏览器必须转化为 es5 语法，</p><p>调用时间：</p><ul><li>1.require 是运行时调用，理论上可以运行在代码的任何地方</li><li>2.import 是编译时调用，所以必须在开头引入</li></ul><p>本质上：</p><ul><li>1.require 是赋值过程，就是将对象、数组、字符串、函数等赋值给变量；</li><li>2.import 是解构过程，使用 babel 之后，也是将 import 转换成 require</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>印象中碰到的一些面试题</title>
      <link href="/2019/07/02/%E8%AE%B0%E5%BF%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/02/%E8%AE%B0%E5%BF%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(5).fill(&#123;&#125;)</span><br><span class="line">[1,2,3,4,5].forEach((item,index)=&gt;&#123;</span><br><span class="line">  a[index].a = item</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a)</span><br><span class="line">//[&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;]</span><br><span class="line">var arr = new Array(5).fill(&#123;&#125;)</span><br><span class="line">[1,2,3,4,5].forEach((item,index)=&gt;&#123;</span><br><span class="line">  a[1].a = item</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a)</span><br><span class="line">// [&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//变量提升</span><br><span class="line">a()</span><br><span class="line">var a = c = function () &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">(function (b) &#123;</span><br><span class="line">  b(), c()</span><br><span class="line">  var b = c = function a() &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">  &#125;</span><br><span class="line">  b()</span><br><span class="line">&#125;)(a);</span><br><span class="line">c()</span><br><span class="line">// 1 2 2 2 2 3 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//深拷贝</span><br><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">  //判断 obj 是否是简单的数据类型</span><br><span class="line">  if (typeof obj == &apos;object&apos;) &#123;</span><br><span class="line">    //复杂数据类型</span><br><span class="line">    var result = obj.constructor == Array ? [] : &#123;&#125;</span><br><span class="line">    for (const key in obj) &#123;</span><br><span class="line">      //复杂数据类型 obj 利用递归拷贝类型</span><br><span class="line">      ;</span><br><span class="line">      (result[key] == typeof obj[key]) == &apos;object&apos; ?</span><br><span class="line">      deepCopy(obj[key]): obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //简单数据类型</span><br><span class="line">    var result = obj</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**防抖节流 */</span><br><span class="line"></span><br><span class="line">function dedule(fn, wait = 50, immedital) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (immedital) &#123;</span><br><span class="line">      //确定是否进行防抖操作</span><br><span class="line">      fn.call(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.call(this, arguments)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  let prev = new Date()</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const arg = arguments</span><br><span class="line">    const now = new Date()</span><br><span class="line">    if (now - prev &gt; wait) &#123;</span><br><span class="line">      fn.call(this, arg)</span><br><span class="line">      prev = new Date()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承</span><br><span class="line"> * 组合继承</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function Father(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayname = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function create(proto) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = proto</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = create(Father.prototype)</span><br><span class="line">// var son1 = new Child()</span><br><span class="line">// son1.sayname()</span><br><span class="line">Child.prototype.sayname()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**数组去重</span><br><span class="line"> * 对于多大数组 进行先排序 arr.sort 在过滤去重</span><br><span class="line"> * 1.使用递归去重</span><br><span class="line"> * 2.使用 filter()过滤重复元素</span><br><span class="line"> */</span><br><span class="line">Array.prototype.distinct = function () &#123;</span><br><span class="line">  var arr = this,</span><br><span class="line">    len = arr.length</span><br><span class="line">  //arr.sort() 对数组进行排序 只能传一个参数</span><br><span class="line">  arr.sort(function (a, b) &#123;</span><br><span class="line">    //对数组进行排序才能方便比较</span><br><span class="line">    return a - b</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function loop(index) &#123;</span><br><span class="line">    //递归判断前一个元素是否等于当前元素(从后往前排序)</span><br><span class="line">    if (index &gt;= 1) &#123;</span><br><span class="line">      if (arr[index] === arr[index - 1]) &#123;</span><br><span class="line">        arr.splice(index, 1)</span><br><span class="line">      &#125;</span><br><span class="line">      loop(index - 1) //递归loop函数进行去重</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop(len)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56]</span><br><span class="line">var b = a.distinct()</span><br><span class="line">console.log(b.toString()) //1,2,3,4,5,6,45,56</span><br><span class="line"></span><br><span class="line">function unique(a) &#123;</span><br><span class="line">  return a</span><br><span class="line">    .concat()</span><br><span class="line">    .sort()</span><br><span class="line">    .filter(function (item, pos, ary) &#123;</span><br><span class="line">      return !pos || item != ary[pos - 1]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = [1, 1, 3, 2, 1, 2, 4]</span><br><span class="line">var ans = unique(d)</span><br><span class="line">console.log(ans) // =&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//实现一个 instanceof</span><br><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">  let proto = left.__proto__,</span><br><span class="line">    prototype = right.prototype</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto == null) return false</span><br><span class="line">    if (proto == prototype) return true</span><br><span class="line">    proto = proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var func = function (a) &#123;</span><br><span class="line">  this.a = a</span><br><span class="line">  return (function (a) &#123;</span><br><span class="line">    a += this.a</span><br><span class="line">    return a</span><br><span class="line">  &#125;)(</span><br><span class="line">    (function (a, b) &#123;</span><br><span class="line">      return a</span><br><span class="line">    &#125;)(3, 5)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">func(7)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">var fn1 = async () =&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">  for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    i == 999 &amp;&amp; (await console.log(4))</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">console.log(5)</span><br><span class="line">//2 4 5 3 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>复习笔记整理--CSS篇</title>
      <link href="/2019/07/02/CSS/"/>
      <url>/2019/07/02/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h1><hr><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><hr><h2 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h2><ul><li>1.所有的 html 都可以看做盒模型</li><li>2.css 盒模型本质上是一个盒子,包含 margin padding border content</li><li>3.通常我们设置的宽高只是 content 值,不包含 border margin padding</li></ul><h2 id="2-BFC-块级格式化上下文"><a href="#2-BFC-块级格式化上下文" class="headerlink" title="2.BFC(块级格式化上下文)"></a>2.BFC(块级格式化上下文)</h2><p>独立创建渲染区域,该区域内的所有元素布局不会影响到外面<br>应用:</p><ul><li><ol><li>阻止 margin 重叠</li></ol></li><li><ol start="2"><li>可以包含浮动元素 – 清除内部浮动</li></ol></li><li><ol start="3"><li>自适应两栏布局</li></ol></li><li><ol start="4"><li>可以阻止元素被浮动元素覆盖</li></ol></li></ul><h2 id="3-层叠上下文"><a href="#3-层叠上下文" class="headerlink" title="3.层叠上下文"></a>3.层叠上下文</h2><p>元素提升为一个比较特殊的图层,在三维空间中(z 轴)高出普通元素,层叠等级 z-index 控制</p><h2 id="4-居中布局"><a href="#4-居中布局" class="headerlink" title="4.居中布局"></a>4.居中布局</h2><ul><li><ol><li>水平居中<ol><li>行类元素:text-align:center</li><li>块级元素:margin:0 auto</li><li>absolute + transform</li><li>flex + justify-content : center</li></ol></li></ol></li><li><ol start="2"><li>垂直居中<ol><li>line-height:height</li><li>absolute + transform</li><li>flex + align-items:center</li><li>table</li></ol></li></ol></li></ul><h2 id="5-选择器优先级"><a href="#5-选择器优先级" class="headerlink" title="5.选择器优先级"></a>5.选择器优先级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. !important &gt; 行内样式 &gt; #id &gt; .class &gt; * &gt; 继承 &gt; 默认</span><br><span class="line">2. 选择器从左到右解析</span><br></pre></td></tr></table></figure><h2 id="6-去除浮动-防止父级高度塌陷"><a href="#6-去除浮动-防止父级高度塌陷" class="headerlink" title="6.去除浮动,防止父级高度塌陷"></a>6.去除浮动,防止父级高度塌陷</h2><ul><li><ol><li>主流方法(伪类):用 after 伪元素清除浮动,清除浮动主要是围绕 clear:both 和如何隐藏</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">   .clearfix:after&#123;   display: block;   </span><br><span class="line">       content:&apos;&apos;;   </span><br><span class="line">       clear: both;  </span><br><span class="line">       height:0;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>创建父级 BFC</li></ol></li><li><ol start="3"><li>父级设置高度</li></ol></li></ul><h2 id="7-link-和-import-区别"><a href="#7-link-和-import-区别" class="headerlink" title="7.link 和@import 区别"></a>7.link 和@import 区别</h2><ul><li><ol><li>link 可以自定义 RSS,定义 Rel 等作用,而@import 只能用于加载 css</li></ol></li><li><ol start="2"><li>当解析 link 时,会自动加载 css,而@import 所引用的 css 只有页面加载完才会解析</li></ol></li><li><ol start="3"><li>link 可以使用 js 动态引入</li></ol></li></ul><h2 id="8-css-预处理器-sass-less"><a href="#8-css-预处理器-sass-less" class="headerlink" title="8.css 预处理器(sass/less)"></a>8.css 预处理器(sass/less)</h2><p>css 预处理器:是将类 css 语言通过 webpack 编译转变成浏览器可读的真正 css,常用功能:</p><ul><li><ol><li>嵌套</li></ol></li><li><ol start="2"><li>变量</li></ol></li><li><ol start="3"><li>循环语句</li></ol></li><li><ol start="4"><li>条件语句</li></ol></li><li><ol start="5"><li>自动前缀</li></ol></li><li><ol start="6"><li>单位转换</li></ol></li></ul><h2 id="9-css-动画"><a href="#9-css-动画" class="headerlink" title="9.css 动画"></a>9.css 动画</h2><ul><li><ol><li>transition:过渡动画</li></ol></li><li><ol start="2"><li>animation</li></ol></li><li><ol start="3"><li>动画属性:translate(位移) scale(旋转)rotate(缩放)</li></ol></li></ul><h2 id="10-rem-转化"><a href="#10-rem-转化" class="headerlink" title="10.rem 转化"></a>10.rem 转化</h2><p>px 是固定单位，<br>em 和 rem 是相对单位，em 是相对父元素 fontSize，层次页面越深 em 换算越复杂<br>rem 是相对根元素，一般我会设置根元素 html 的 fontSize 为 62.5%或者 10px，这样换算就是 1:10，设置单位为 rem</p><h2 id="11-flex-布局"><a href="#11-flex-布局" class="headerlink" title="11.flex 布局"></a>11.flex 布局</h2><p>flex 弹性盒子，display:flex 设置弹性盒子，其中他是要分为主轴 just 和侧轴 ali</p><h2 id="12-HTML5-新特性"><a href="#12-HTML5-新特性" class="headerlink" title="12.HTML5 新特性"></a>12.HTML5 新特性</h2><p>向前兼容性，跨平台运行，简单易用，用户友好</p><ul><li>1.新增语义化标签：header、footer、nav 、canvas</li><li>2.新增本地存储 localStorage、sessionStorage</li><li>3.新增表单功能：date 选择日期、color 颜色、email 邮箱、month 月份、search 搜索、tel 电话、week 选择年周</li><li>4.css3 新增跟多选择器，before，after，first-child 等等，还有文字和盒子阴影包括媒体查询等</li><li>5.history 对象</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/02/hello-world/"/>
      <url>/2019/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
