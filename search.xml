<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS</title>
      <link href="/2019/07/02/JS/"/>
      <url>/2019/07/02/JS/</url>
      
        <content type="html"><![CDATA[<h1 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h2><ul><li><ol><li>基本数据类型 : string / number / boolean / underfined /null</li></ol></li><li><ol start="2"><li>复杂数据类型 : Object / Array / Date / Function / String / Number / Math / Null</li></ol></li><li><ol start="3"><li>引用类型 : 对象(Object) 数组(Array) 函数(Function)</li></ol></li></ul><p>面向对象的三大特性：封装（复用信息隐蔽），继承（获取已存在对象的已知属性和方法），多态（同一操作会产生不同的解析和行为）</p><h2 id="2-原型-构造函数-实例"><a href="#2-原型-构造函数-实例" class="headerlink" title="2.原型 / 构造函数 / 实例"></a>2.原型 / 构造函数 / 实例</h2><ul><li>1.<strong>原型(protoType)</strong> : 在构造函数创建出来的时候,系统会默认帮构造函数创建一个与之关联的自定义构造函数,构造函数的原型对象默认是一个空对象,自定义构造函数创建出来的对象自动拥有和共享该构造函数的原型对象中的所有属性和方法,构造函数 <strong>.prototype</strong> 指向他的原型对象,或者实例 <strong>.__proto__</strong> 指向创建实例对象的构造函数原型对象,原型对象的 constructor 属性指向对应的构造函数</li><li><ol start="2"><li><strong>构造函数:</strong> 可以通过 new 来创建一个对象的函数</li></ol></li><li><ol start="3"><li><strong>实例:</strong> 通过构造函数和 new 创建出来的对象,实例可以通过 <strong>.__proto__</strong> 指向原型,通过 constructor 指向构造函数<br><img src="../images/yuanxing.png" alt="原型"></li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//instance 为实例,构造 x 函数 Object,构造函数有一个 prototype 属性指向原型对象</span><br><span class="line">const instance = new Object()</span><br><span class="line">// 原型对象 prototype</span><br><span class="line">const prototype = Object.prototype</span><br><span class="line">实例.\_ _proto _ \_== 原型</span><br><span class="line">原型.constructor == 构造函数</span><br><span class="line">构造函数.prototype == 原型</span><br><span class="line">实例.construtor == 构造函数</span><br></pre></td></tr></table></figure><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h2><p>原型链是有原型对象组成,每个对象都有 <strong>.__proto__</strong> 属性,指向创建该对象的构造函数的原型,<strong>.__proto__</strong> 见对象连接起来组成原型链。是一个用来 <strong>实现继承和共享属性</strong>的有限对象链。</p><ul><li><ol><li>属性查找机制: 当查找对象的属性时,如果实例对象自身不存在该属性,则沿着原型链往上一级查找,找到则输出,找不到继续往上查找,直到找到顶层 Object.protoType,如果还没有就输出 underfined</li></ol></li><li><ol start="2"><li>属性修改机制: 只会修改实例对象本身属性,如果不存在,则添加该属性,如果需要修改原型属性时,则可以用 b.prototype.x = 2 ;但是这样会造成所有继承该对象的实例的属性发生改变。</li></ol></li></ul><p><img src="../images/yuanxinlian.png" alt="原型"></p><h2 id="4-执行上下文（EC）"><a href="#4-执行上下文（EC）" class="headerlink" title="4.执行上下文（EC）"></a>4.执行上下文（EC）</h2><p>执行上下文可以简单理解为一个对象：</p><ul><li><ol><li>它包含了三个部分：<ol><li>变量对象（VO）</li><li>作用域链（词法作用域）</li><li>this 指向</li></ol></li></ol></li><li><ol start="2"><li>他的类型：<ol><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ol></li></ol></li><li><ol start="3"><li><p>代码执行过程：</p><ol><li>创建全局上下文（global EC）</li><li>全局执行上下文(caller)逐行自上而下执行。遇到函数时，函数执行上下文（callee）被 push 到执行栈顶层</li><li>函数执行上下文被激活，成为 active EC,开始执行函数中的代码，cakker 被挂起</li><li>函数执行后，callee 被 pop 移出出执行栈，控制权交还全局上下文，继<br>续执行</li></ol></li></ol></li></ul><p>##5.变量对象<br>变量对象，是执行上下文中的一部分，可以抽象为一种<strong>数据作用域</strong>，其实也可以理解为就是一个简单的对象，他储存着该执行上下文中的所有<strong>变量和函数声明（不包含函数表达式）</strong></p><p>##6.作用域<br><strong>变量作用域:</strong> 变量作用域分为两种:全局变量和局部变量<br>执行上下文中还包含了作用域链。作用域其实可以理解为该上下文中声明的变量和声明的作用范围。可分为<strong>块级作用域</strong>和<strong>函数作用域</strong><br>特性：</p><ul><li>1.<strong>声明提前：</strong> 一个声明在函数体内都是可见的，函数优先于变量。</li><li>2.非匿名自执行函数，函数变量为只读状态，无法被修改</li></ul><p>##7.作用域链<br>我们可以在执行上下文是访问到父级甚至全局变量，这便是作用域链，作用域链可以理解为一组对象列表，包含<strong>父级和自身的变量对象</strong>，因此我们便能通过作用域链访问到父级里的声明或者函数</p><p>##8.闭包<br>闭包：闭包就是能够获取其他函数内部的变量的函数，由于 js 中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为<strong>定义在一个函数内部的函数</strong>，所以本质上闭包就是将函数内部和函数外部连接起来的一座桥梁，<br><strong>闭包的用途：</strong> 第一个就是读取函数内部的变量，第二个就是让这些变量的值始终保存在内存中<br>使用闭包会使得函数中的变量一直保存在内存中，内存消耗大会造成性能问题，在 ie 中会造成内存泄漏。<br>在闭包中，多个子函数会同时指向父级，是完全共享，因此当父级变量被修改时，所有的子函数都会受到影响。<br>解决办法：</p><ul><li>1.变量以函数参数的形式传入；</li><li>2.使用块级作用域，避免共享</li></ul><p>##9.对象拷贝</p><ul><li>1.浅拷贝:以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响<br>①Object.assign<br>② 展开运算符(…)</li><li>2.深拷贝：完全拷贝一个新对象，修改时元对象不再受到任何影响<br>①JSON.parse（JSON.stringify（obj））：性能最快 1)具有循环引用的对象时，报错 2)当值为 underfined 或者 symbol 时，无法拷贝<br>② 递归进行逐一赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">    if (typeof obj == &apos;object&apos;) &#123;</span><br><span class="line">      // 复杂数据类型</span><br><span class="line">      var result = obj.construction == Array ? [] : &#123;&#125;</span><br><span class="line">      for (const key in obj) &#123;</span><br><span class="line">        result[key] == typeof obj[key] == &apos;object&apos; ? deepCopy(obj[key]) : obj[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var result = obj</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##11.instanceof</p><ul><li>1.能在实例的原型对象链中找到该构造函数的 prototype 属性所指向的原型对象，返回 true</li><li>2.获取对象的真是属性 object.prototype.toString.call(具体对象)</li></ul><p>##12.继承<br>在 js 中，继承通常指原型链继承，指定原型，通过原型链继承原型上的属性或者方法。<br>继承：通过一定的方式实现让某一个类型 a 获取另外一个类型 b 的属性和方法，其中 a 称为子类型，b 称为父类型或者超类型<br><strong>原型式继承：</strong> 设置原型对的属性和方法，让所有的实例化对象都拥有属性和方法<br><strong>原型链继承：</strong> 实质就是重写原型对象，重写原型对象的位置，必须是先实现原型继承，然后在设置子对象的原型属性和方法，完成继承后不能使用字面量方式创建原型<br><strong>经典继承：</strong> 要用到 call 和 apply 方法，解决了实例对象的共享问题<br><strong>组合继承：</strong> 使用原型链实现对原型属性和方法的继承，用伪造构造函数实现属性的继承<br>使用 es6 的语法糖 class / extends</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//原型式继承</span><br><span class="line"> //1.设置父对象的构造函数</span><br><span class="line"> function Father() &#123;</span><br><span class="line">   this.name = &apos;father&apos;</span><br><span class="line">   this.showName = function () &#123;</span><br><span class="line">     console.log(this.name)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //3.提供子对象的构造函数</span><br><span class="line"> function Son() &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> //4.设置原型继承</span><br><span class="line"> Son.prototype = new Father()</span><br><span class="line"> //5.实例化对象,实现继承</span><br><span class="line"> var son1 = new Son()</span><br><span class="line"> console.log(son1.name)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//原型链继承</span><br><span class="line">//设置父类型</span><br><span class="line">function Father() &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">  this.showName = function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//2.设置父类型原型对象上的属性和方法</span><br><span class="line">Father.prototype.info = &apos;father info&apos;</span><br><span class="line">Father.prototype.showInfo = function () &#123;</span><br><span class="line">  console.log(this.info)</span><br><span class="line">&#125;</span><br><span class="line">//3,提供子类型</span><br><span class="line">function Son() &#123;&#125;</span><br><span class="line">//4.设置继承,继承父类型上的所有属性和方法</span><br><span class="line">Son.prototype = new Father()</span><br><span class="line">//5.将子类的构造函数 重新指向会子类型</span><br><span class="line">Son.prototype.construction = Son</span><br><span class="line">var son2 = new Son()</span><br><span class="line">console.log(son2.info) //father info</span><br><span class="line">console.log(son2.showInfo()) //father info</span><br><span class="line">son2.info = &apos;123&apos;</span><br><span class="line">var father = new Father()</span><br><span class="line">console.log(father.info) //father info</span><br><span class="line">console.log(son2.info) //123</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;dog&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  showName(say) &#123;</span><br><span class="line">    console.log(this.name + &apos;name&apos; + say)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.showName(&apos;阿黄&apos;) //dogname阿黄</span><br><span class="line"></span><br><span class="line">class Cat extends Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.name = &apos;猫&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat1 = new Cat()</span><br><span class="line">cat1.showName(&apos;橘猫&apos;) //猫name橘猫</span><br></pre></td></tr></table></figure><p>##13.类型转换<br>类型转换分为强类型转换和隐式类型转换<br>强制：（parseInt,parseFloat,Number()）<br>隐式：（==) 1 == ”1” //true<br>null == undefined //true</p><p>##14.模块化<br>模块化开发可以大大提高项目的可维护性，可拓展性和可协作性，通常，我们在浏览器中使用 es6 的模块化支持，在 node 中使用 common.js 的模块化支持<br>分类：</p><ul><li>1.es6：import / exports</li><li>2.commonjs : require / module.export / export</li><li>3.amd : require / defined</li></ul><p>require 和 import 区别：</p><ul><li>1.require 支持动态导入，import 不支持</li><li>2.require 是同步导入，import 属于异步导入</li><li>3.require 是值拷贝，导出值变化不会影响导入值，import 指向内存地址，导入值会随导出值而变化</li></ul><p>##15.防抖与节流<br>防抖与节流函数是一种最常用的高频触发优化方式，能对性能有较大的帮助。</p><ul><li>1.防抖：将多次高频操作优化为只在最后一次执行，通常使用场景为：用户输入，只需要再输入完成后做一次验证即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function dedule(fn, wait = 50, immdital) &#123;</span><br><span class="line">    var timer</span><br><span class="line">    return function () &#123;</span><br><span class="line">      if (immdital) &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">      if (timer) clearTimeout(timer)</span><br><span class="line">      timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>2.节流：每隔一段时间后执行一次，也就是降低频率，将最高频操作优化成低频操作，通常使用场景：滚动条事件或者 resize 事件，通常每隔 100~500ms 执行一次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function rhtottle(fn, wait = 50, immediately) &#123;</span><br><span class="line">    var timer</span><br><span class="line">    return function () &#123;</span><br><span class="line">      if (immediately) &#123;</span><br><span class="line">        fn.call(this, arguments)</span><br><span class="line">        immediately = false</span><br><span class="line">      &#125;</span><br><span class="line">      if (!timer) &#123;</span><br><span class="line">        timer = setTimeout(() =&gt; &#123;</span><br><span class="line">          fn.call(this, arguments)</span><br><span class="line">          timer = null</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##16.函数执行改变 this<br>由于 JS 的设计原理：在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数内部获取当前运行环境，this<br>函数运行环境，谁调用了函数就指向谁</p><ul><li>1.obj.fn()，obj 调用函数，即函数中的 this == obj</li><li>2.fn（），这里就是 window.fn（），this == window</li></ul><p>手动改变 this 指向</p><ul><li>1.call：fn.call（target，1,2）</li><li>2.apply：fn.apply(terger, [1 , 2] )</li><li>3.bind：fn.bind(target)(1,2)</li></ul><p><strong>call 和 apply 和 bind 都是 Function 对象自带三个方法，都是为了改变函数内部 this 指向</strong></p><ul><li>1.三者的第一个参数都是 this 指向的对象</li><li>2.都可以利用后- 续参数传值</li><li>3.bind 返回对应<strong>函数</strong>，便于稍后调用，apply 和 call 则是立即调用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function fruits() &#123;&#125;</span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">  color: &apos;red&apos;,</span><br><span class="line">  say: function () &#123;</span><br><span class="line">    console.log(&apos;My color is&apos; + this.color);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var apple = new fruits;</span><br><span class="line">apple.say();</span><br><span class="line">// 此时方法里面的this 指的是fruits</span><br><span class="line">// 结果： My color is red</span><br><span class="line">var banana = &#123;</span><br><span class="line">  color: &apos;yellow&apos;</span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana);</span><br><span class="line">//此时的this的指向已经同过call（）方法改变了，指向的是banana，this.color就是banana.color=&apos;yellow&apos;;</span><br><span class="line">//结果是My color is yellow</span><br><span class="line">apple.say.apply(banana);</span><br><span class="line">//同理，此时的this的指向已经同过apply（）方法改变了，指向的是banana，this.color就是banana.color =&apos;yellow&apos;;</span><br><span class="line">//My color is yellow</span><br><span class="line">// 如果传入的是 null：</span><br><span class="line">apple.say.apply(</span><br><span class="line">  null</span><br><span class="line">);</span><br><span class="line">// null是window下的，此时，this 就指向了window ，但是window下并没有clolr这个属性，</span><br><span class="line">//因此this.clolr就是window.color=undefined;//My color is undefined</span><br><span class="line">var bar = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo = &#123;</span><br><span class="line">  x: 3</span><br><span class="line">&#125;</span><br><span class="line">bar(); // undefinedvar</span><br><span class="line">func = bar.bind(foo);</span><br><span class="line">//此时this已经指向了foo，但是用bind（）方法并不会立即执行，</span><br><span class="line">//而是创建一个新函数，如果要直接调用的话 可以 bar.bind(foo)（）</span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure><p>##17.ES6 / ES7</p><ul><li>1.声明<br>①let / const：块级作用域、不存在变量提升、暂时性死区、不允许重复声明<br>②const：声明常量、常量的值不可被修改，但是 const 指向一个地址时候，是可以被修改的彻底将对象冻结可以使用 Obj.freeze()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">arr.fn = &apos;被改变了&apos;</span><br><span class="line">console.log(arr) //&#123; fn: &apos;被改变了&apos;&#125;</span><br></pre></td></tr></table></figure><ul><li>2.解构赋值<br>es6 允许按照一定的模式，从数组和对象中提取值，对对象进行赋值，称为解构<br>本质上,这种写法属于”模式匹配”,只要等号两边模式相同,左边的变量就会被赋予对应值,</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [a,b,c] = [12,13]</span><br><span class="line">console.log(a) //12</span><br><span class="line">console.log(b) //13</span><br><span class="line">console.log(c) //undefined</span><br><span class="line"></span><br><span class="line">let [a,...b] = [12,13,14,15]</span><br><span class="line">console.log(a) //12</span><br><span class="line">console.log(b) //[13,14,15]</span><br></pre></td></tr></table></figure><ul><li>3.class / extend ：类声明和继承<br>class 语法相对原型、构造函数、继承更接近传统语法，可以让对象原型写法更加清晰</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.name = &apos;dog&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  showName(say) &#123;</span><br><span class="line">    console.log(this.name + &apos;name&apos; + say)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog1 = new Dog()</span><br><span class="line">dog1.showName(&apos;阿黄&apos;) //dogname阿黄</span><br><span class="line"></span><br><span class="line">class Cat extends Dog &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.name = &apos;猫&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat1 = new Cat()</span><br><span class="line">cat1.showName(&apos;橘猫&apos;) //猫name橘猫</span><br></pre></td></tr></table></figure><ul><li><p>4.Set / Map : 新的数据结构 set 中值是唯一的，可以用来进行数组去重<br>Map:一种新的数据结构,键的范围不限于字符串,各种类型的值都可以当做键</p></li><li><p>5.异步解决方案：</p><ul><li><p>①promise：使用同步的方法解决异步操作，解决 ajax 的回调地狱</p><pre><code>1).then()返回一个 promise 对象，可以连续调用.then()完成回调2)all 方法 then 方法 catch 方法3)promise 是一个对象可以通过 new 调用，有两个参数 resolve（决定）和 reject（拒绝）这两个参数页数函数，接着可以使用。then 调用 promise。</code></pre></li><li><p>②generator（生产者）：<br>但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态（yield 语句在英语里的意思就是“产出”）。<br>1)yield：暂停代码<br>2)next（）：继续执行代码</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function\* helloWorld() &#123;</span><br><span class="line">   yield &apos;hello&apos;;</span><br><span class="line">   yield &apos;world&apos;;</span><br><span class="line">   return &apos;ending&apos;;</span><br><span class="line">&#125;</span><br><span class="line">const generator = helloWorld();</span><br><span class="line">generator.next() // &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class="line">generator.next() // &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class="line">generator.next() // &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class="line">generator.next() // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>③await / async：是 generator 的语法糖，babel 中是基于 promise 实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function getUserByAsync()&#123;</span><br><span class="line"> let user = await fetchUser();</span><br><span class="line"> return user;</span><br><span class="line"> &#125;</span><br><span class="line"> const user = await getUserByAsync()</span><br><span class="line"> console.log(user)</span><br></pre></td></tr></table></figure><p>async(异步操作)/await(等待操作) 简单讲就是 async 函数会返回一个 promises 对象,await 就是等待,等待所有的异步操作完成后再调用,完成将异步变成同步操作,终结回调,当然 async 内部发生错误会被 promise 对象变成 reject 对象被 catch 捕捉,一旦 await 抛出错误后续就不再执行了</p><ul><li>6.模板语法 ：<br><code>${varible}</code> 字符串添加遍历接口,可以被 for…of 遍历循环</li><li>7.模块（module）体系<br>impotent / export default</li><li>8.箭头函数:<br>没有 arguments,没有 prototype 属性,不可以作为构造函数,改变 this 指向,指向上下文</li><li>9.扩展运算符(…)<br>Object.assign()对象合并</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>印象中碰到的一些面试题</title>
      <link href="/2019/07/02/%E8%AE%B0%E5%BF%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/02/%E8%AE%B0%E5%BF%86%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(5).fill(&#123;&#125;)</span><br><span class="line">[1,2,3,4,5].forEach((item,index)=&gt;&#123;</span><br><span class="line">  a[index].a = item</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a)</span><br><span class="line">//[&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;]</span><br><span class="line">var arr = new Array(5).fill(&#123;&#125;)</span><br><span class="line">[1,2,3,4,5].forEach((item,index)=&gt;&#123;</span><br><span class="line">  a[1].a = item</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a)</span><br><span class="line">// [&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;,&#123;a:5&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//变量提升</span><br><span class="line">a()</span><br><span class="line">var a = c = function () &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">(function (b) &#123;</span><br><span class="line">  b(), c()</span><br><span class="line">  var b = c = function a() &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">  &#125;</span><br><span class="line">  b()</span><br><span class="line">&#125;)(a);</span><br><span class="line">c()</span><br><span class="line">// 1 2 2 2 2 3 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//深拷贝</span><br><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">  //判断 obj 是否是简单的数据类型</span><br><span class="line">  if (typeof obj == &apos;object&apos;) &#123;</span><br><span class="line">    //复杂数据类型</span><br><span class="line">    var result = obj.constructor == Array ? [] : &#123;&#125;</span><br><span class="line">    for (const key in obj) &#123;</span><br><span class="line">      //复杂数据类型 obj 利用递归拷贝类型</span><br><span class="line">      ;</span><br><span class="line">      (result[key] == typeof obj[key]) == &apos;object&apos; ?</span><br><span class="line">      deepCopy(obj[key]): obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //简单数据类型</span><br><span class="line">    var result = obj</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**防抖节流 */</span><br><span class="line"></span><br><span class="line">function dedule(fn, wait = 50, immedital) &#123;</span><br><span class="line">  var timer</span><br><span class="line">  return function () &#123;</span><br><span class="line">    if (immedital) &#123;</span><br><span class="line">      //确定是否进行防抖操作</span><br><span class="line">      fn.call(this, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.call(this, arguments)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function throttle(fn, wait) &#123;</span><br><span class="line">  let prev = new Date()</span><br><span class="line">  return function () &#123;</span><br><span class="line">    const arg = arguments</span><br><span class="line">    const now = new Date()</span><br><span class="line">    if (now - prev &gt; wait) &#123;</span><br><span class="line">      fn.call(this, arg)</span><br><span class="line">      prev = new Date()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 继承</span><br><span class="line"> * 组合继承</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">function Father(name) &#123;</span><br><span class="line">  this.name = name</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayname = function () &#123;</span><br><span class="line">  console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;&#125;</span><br><span class="line"></span><br><span class="line">function create(proto) &#123;</span><br><span class="line">  function F() &#123;&#125;</span><br><span class="line">  F.prototype = proto</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = create(Father.prototype)</span><br><span class="line">// var son1 = new Child()</span><br><span class="line">// son1.sayname()</span><br><span class="line">Child.prototype.sayname()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**数组去重</span><br><span class="line"> * 对于多大数组 进行先排序 arr.sort 在过滤去重</span><br><span class="line"> * 1.使用递归去重</span><br><span class="line"> * 2.使用 filter()过滤重复元素</span><br><span class="line"> */</span><br><span class="line">Array.prototype.distinct = function () &#123;</span><br><span class="line">  var arr = this,</span><br><span class="line">    len = arr.length</span><br><span class="line">  //arr.sort() 对数组进行排序 只能传一个参数</span><br><span class="line">  arr.sort(function (a, b) &#123;</span><br><span class="line">    //对数组进行排序才能方便比较</span><br><span class="line">    return a - b</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function loop(index) &#123;</span><br><span class="line">    //递归判断前一个元素是否等于当前元素(从后往前排序)</span><br><span class="line">    if (index &gt;= 1) &#123;</span><br><span class="line">      if (arr[index] === arr[index - 1]) &#123;</span><br><span class="line">        arr.splice(index, 1)</span><br><span class="line">      &#125;</span><br><span class="line">      loop(index - 1) //递归loop函数进行去重</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop(len)</span><br><span class="line">  return arr</span><br><span class="line">&#125;</span><br><span class="line">var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,56,45,56]</span><br><span class="line">var b = a.distinct()</span><br><span class="line">console.log(b.toString()) //1,2,3,4,5,6,45,56</span><br><span class="line"></span><br><span class="line">function unique(a) &#123;</span><br><span class="line">  return a</span><br><span class="line">    .concat()</span><br><span class="line">    .sort()</span><br><span class="line">    .filter(function (item, pos, ary) &#123;</span><br><span class="line">      return !pos || item != ary[pos - 1]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var d = [1, 1, 3, 2, 1, 2, 4]</span><br><span class="line">var ans = unique(d)</span><br><span class="line">console.log(ans) // =&gt; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//实现一个 instanceof</span><br><span class="line">function instanceOf(left, right) &#123;</span><br><span class="line">  let proto = left.__proto__,</span><br><span class="line">    prototype = right.prototype</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (proto == null) return false</span><br><span class="line">    if (proto == prototype) return true</span><br><span class="line">    proto = proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var func = function (a) &#123;</span><br><span class="line">  this.a = a</span><br><span class="line">  return (function (a) &#123;</span><br><span class="line">    a += this.a</span><br><span class="line">    return a</span><br><span class="line">  &#125;)(</span><br><span class="line">    (function (a, b) &#123;</span><br><span class="line">      return a</span><br><span class="line">    &#125;)(3, 5)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">func(7)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">var fn1 = async () =&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">  for (var i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    i == 999 &amp;&amp; (await console.log(4))</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line">console.log(5)</span><br><span class="line">//2 4 5 3 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2019/07/02/CSS/"/>
      <url>/2019/07/02/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h1><hr><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><hr><h2 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h2><ul><li>1.所有的 html 都可以看做盒模型</li><li>2.css 盒模型本质上是一个盒子,包含 margin padding border content</li><li>3.通常我们设置的宽高只是 content 值,不包含 border margin padding</li></ul><h2 id="2-BFC-块级格式化上下文"><a href="#2-BFC-块级格式化上下文" class="headerlink" title="2.BFC(块级格式化上下文)"></a>2.BFC(块级格式化上下文)</h2><p>独立创建渲染区域,该区域内的所有元素布局不会影响到外面<br>应用:</p><ul><li><ol><li>阻止 margin 重叠</li></ol></li><li><ol start="2"><li>可以包含浮动元素 – 清除内部浮动</li></ol></li><li><ol start="3"><li>自适应两栏布局</li></ol></li><li><ol start="4"><li>可以阻止元素被浮动元素覆盖</li></ol></li></ul><h2 id="3-层叠上下文"><a href="#3-层叠上下文" class="headerlink" title="3.层叠上下文"></a>3.层叠上下文</h2><p>元素提升为一个比较特殊的图层,在三维空间中(z 轴)高出普通元素,层叠等级 z-index 控制</p><h2 id="4-居中布局"><a href="#4-居中布局" class="headerlink" title="4.居中布局"></a>4.居中布局</h2><ul><li><ol><li>水平居中<ol><li>行类元素:text-align:center</li><li>块级元素:margin:0 auto</li><li>absolute + transform</li><li>flex + justify-content : center</li></ol></li></ol></li><li><ol start="2"><li>垂直居中<ol><li>line-height:height</li><li>absolute + transform</li><li>flex + align-items:center</li><li>table</li></ol></li></ol></li></ul><h2 id="5-选择器优先级"><a href="#5-选择器优先级" class="headerlink" title="5.选择器优先级"></a>5.选择器优先级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. !important &gt; 行内样式 &gt; #id &gt; .class &gt; * &gt; 继承 &gt; 默认</span><br><span class="line">2. 选择器从左到右解析</span><br></pre></td></tr></table></figure><h2 id="6-去除浮动-防止父级高度塌陷"><a href="#6-去除浮动-防止父级高度塌陷" class="headerlink" title="6.去除浮动,防止父级高度塌陷"></a>6.去除浮动,防止父级高度塌陷</h2><ul><li><ol><li>主流方法(伪类):用 after 伪元素清除浮动,清除浮动主要是围绕 clear:both 和如何隐藏</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">content</span><br><span class="line">   .clearfix:after&#123;   display: block;   </span><br><span class="line">       content:&apos;&apos;;   </span><br><span class="line">       clear: both;  </span><br><span class="line">       height:0;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>创建父级 BFC</li></ol></li><li><ol start="3"><li>父级设置高度</li></ol></li></ul><h2 id="7-link-和-import-区别"><a href="#7-link-和-import-区别" class="headerlink" title="7.link 和@import 区别"></a>7.link 和@import 区别</h2><ul><li><ol><li>link 可以自定义 RSS,定义 Rel 等作用,而@import 只能用于加载 css</li></ol></li><li><ol start="2"><li>当解析 link 时,会自动加载 css,而@import 所引用的 css 只有页面加载完才会解析</li></ol></li><li><ol start="3"><li>link 可以使用 js 动态引入</li></ol></li></ul><h2 id="8-css-预处理器-sass-less"><a href="#8-css-预处理器-sass-less" class="headerlink" title="8.css 预处理器(sass/less)"></a>8.css 预处理器(sass/less)</h2><p>css 预处理器:是将类 css 语言通过 webpack 编译转变成浏览器可读的真正 css,常用功能:</p><ul><li><ol><li>嵌套</li></ol></li><li><ol start="2"><li>变量</li></ol></li><li><ol start="3"><li>循环语句</li></ol></li><li><ol start="4"><li>条件语句</li></ol></li><li><ol start="5"><li>自动前缀</li></ol></li><li><ol start="6"><li>单位转换</li></ol></li></ul><h2 id="9-css-动画"><a href="#9-css-动画" class="headerlink" title="9.css 动画"></a>9.css 动画</h2><ul><li><ol><li>transition:过渡动画</li></ol></li><li><ol start="2"><li>animation</li></ol></li><li><ol start="3"><li>动画属性:translate(位移) scale(旋转)rotate(缩放)</li></ol></li></ul><h2 id="10-rem-转化"><a href="#10-rem-转化" class="headerlink" title="10.rem 转化"></a>10.rem 转化</h2><p>px 是固定单位，<br>em 和 rem 是相对单位，em 是相对父元素 fontSize，层次页面越深 em 换算越复杂<br>rem 是相对根元素，一般我会设置根元素 html 的 fontSize 为 62.5%或者 10px，这样换算就是 1:10，设置单位为 rem</p><h2 id="11-flex-布局"><a href="#11-flex-布局" class="headerlink" title="11.flex 布局"></a>11.flex 布局</h2><p>flex 弹性盒子，display:flex 设置弹性盒子，其中他是要分为主轴 just 和侧轴 ali</p><h2 id="12-HTML5-新特性"><a href="#12-HTML5-新特性" class="headerlink" title="12.HTML5 新特性"></a>12.HTML5 新特性</h2><p>向前兼容性，跨平台运行，简单易用，用户友好</p><ul><li>1.新增语义化标签：header、footer、nav 、canvas</li><li>2.新增本地存储 localStorage、sessionStorage</li><li>3.新增表单功能：date 选择日期、color 颜色、email 邮箱、month 月份、search 搜索、tel 电话、week 选择年周</li><li>4.css3 新增跟多选择器，before，after，first-child 等等，还有文字和盒子阴影包括媒体查询等</li><li>5.history 对象</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/02/hello-world/"/>
      <url>/2019/07/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
  
</search>
